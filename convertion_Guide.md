# Ø³ÛŒØ³ØªÙ… Ø®ÙˆØ¯Ú©Ø§Ø± ØªØ¨Ø¯ÛŒÙ„ Ù…Ø­ØªÙˆØ§ Ø¨Ø§ ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´Ù…Ù†Ø¯ Preamble

## ğŸ¯ Ø¯Ø±Ú© Ø¯Ù‚ÛŒÙ‚ Ù†ÛŒØ§Ø² Ø´Ù…Ø§

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Ú†Ø§Ù„Ø´ ÙˆØ§Ù‚Ø¹ÛŒ                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  ğŸ“š Ú©ØªØ§Ø¨ A          ğŸ“š Ú©ØªØ§Ø¨ B          ğŸ“š Ú©ØªØ§Ø¨ C               â”‚
â”‚  â”œâ”€ ÙÙˆÙ†Øª: Vazir     â”œâ”€ ÙÙˆÙ†Øª: Sahel     â”œâ”€ ÙÙˆÙ†Øª: Samim         â”‚
â”‚  â”œâ”€ Ø±Ù†Ú¯: Ø¢Ø¨ÛŒ/Ù‚Ø±Ù…Ø²   â”œâ”€ Ø±Ù†Ú¯: Ø³Ø¨Ø²/Ø·Ù„Ø§ÛŒÛŒ  â”œâ”€ Ø±Ù†Ú¯: Ø¨Ù†ÙØ´/Ù†Ø§Ø±Ù†Ø¬ÛŒ   â”‚
â”‚  â””â”€ Ø§Ø³ØªØ§ÛŒÙ„ TikZ A   â””â”€ Ø§Ø³ØªØ§ÛŒÙ„ TikZ B   â””â”€ Ø§Ø³ØªØ§ÛŒÙ„ TikZ C       â”‚
â”‚         â”‚                  â”‚                  â”‚                  â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                            â”‚                                     â”‚
â”‚                            â–¼                                     â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚              â”‚  Ø³ÛŒØ³ØªÙ… Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ¨Ø¯ÛŒÙ„    â”‚                        â”‚
â”‚              â”‚  (Ø®ÙˆØ¯Ú©Ø§Ø± Ùˆ Ø¨Ø¯ÙˆÙ† Ù†ÛŒØ§Ø²   â”‚                        â”‚
â”‚              â”‚   Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÛŒ)       â”‚                        â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                            â”‚                                     â”‚
â”‚                            â–¼                                     â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚              â”‚     ÙˆØ¨â€ŒØ³Ø§ÛŒØª ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡     â”‚                        â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø³ÛŒØ³ØªÙ… Ù‡ÙˆØ´Ù…Ù†Ø¯

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Ù…Ø¹Ù…Ø§Ø±ÛŒ Content Pipeline                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                â”‚
â”‚   â”‚ Ù…Ù†Ø¨Ø¹ Ù…Ø­ØªÙˆØ§  â”‚ â† LaTeX, Markdown, PDF                        â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                                â”‚
â”‚          â”‚                                                        â”‚
â”‚          â–¼                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚         Û±. Content Analyzer             â”‚                   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                   â”‚
â”‚   â”‚  â”‚  Preamble   â”‚  â”‚   Style         â”‚  â”‚                   â”‚
â”‚   â”‚  â”‚  Parser     â”‚  â”‚   Extractor     â”‚  â”‚                   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                      â”‚                                           â”‚
â”‚                      â–¼                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚         Û². Config Generator             â”‚                   â”‚
â”‚   â”‚  â€¢ ØªÙˆÙ„ÛŒØ¯ Ø®ÙˆØ¯Ú©Ø§Ø± ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡Ø± Ú©ØªØ§Ø¨        â”‚                   â”‚
â”‚   â”‚  â€¢ Ù†Ú¯Ø§Ø´Øª Ø±Ù†Ú¯â€ŒÙ‡Ø§ Ø¨Ù‡ CSS                  â”‚                   â”‚
â”‚   â”‚  â€¢ ØªØ´Ø®ÛŒØµ ÙÙˆÙ†Øªâ€ŒÙ‡Ø§                        â”‚                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                      â”‚                                           â”‚
â”‚                      â–¼                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚         Û³. Smart Renderer               â”‚                   â”‚
â”‚   â”‚  â€¢ TikZ â†’ SVG (Ø¨Ø§ Ø§Ø³ØªØ§ÛŒÙ„ ØµØ­ÛŒØ­)         â”‚                   â”‚
â”‚   â”‚  â€¢ Tables â†’ HTML                        â”‚                   â”‚
â”‚   â”‚  â€¢ Math â†’ KaTeX                         â”‚                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                      â”‚                                           â”‚
â”‚                      â–¼                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚         Û´. Output Generator             â”‚                   â”‚
â”‚   â”‚  â€¢ Markdown + Frontmatter               â”‚                   â”‚
â”‚   â”‚  â€¢ CSS Variables                        â”‚                   â”‚
â”‚   â”‚  â€¢ Asset Management                     â”‚                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡ Ú©Ø§Ù…Ù„

```
your-site/
â”œâ”€â”€ content-source/                    # Ù…Ù†Ø§Ø¨Ø¹ Ø§ØµÙ„ÛŒ (Ø¯Ø³Øª Ù†Ø²Ù†ÛŒØ¯!)
â”‚   â”œâ”€â”€ books/
â”‚   â”‚   â”œâ”€â”€ transition-guide/
â”‚   â”‚   â”‚   â”œâ”€â”€ main.tex              # ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ Ø¨Ø§ preamble
â”‚   â”‚   â”‚   â”œâ”€â”€ preamble.tex          # ÛŒØ§ preamble Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡
â”‚   â”‚   â”‚   â”œâ”€â”€ chapters/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ch01.tex
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ch02.tex
â”‚   â”‚   â”‚   â””â”€â”€ images/
â”‚   â”‚   â””â”€â”€ another-book/
â”‚   â”‚       â””â”€â”€ ...
â”‚   â””â”€â”€ articles/
â”‚       â”œâ”€â”€ article1.tex
â”‚       â””â”€â”€ article2.md               # Markdown Ù‡Ù… Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø´ÙˆØ¯
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ lib/                          # Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ
â”‚   â”‚   â”œâ”€â”€ preamble-parser.mjs       # ØªØ­Ù„ÛŒÙ„ preamble
â”‚   â”‚   â”œâ”€â”€ style-extractor.mjs       # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§
â”‚   â”‚   â”œâ”€â”€ tikz-renderer.mjs         # Ø±Ù†Ø¯Ø± Ù†Ù…ÙˆØ¯Ø§Ø±Ù‡Ø§
â”‚   â”‚   â”œâ”€â”€ markdown-processor.mjs    # Ù¾Ø±Ø¯Ø§Ø²Ø´ Markdown
â”‚   â”‚   â””â”€â”€ config-generator.mjs      # ØªÙˆÙ„ÛŒØ¯ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
â”‚   â”‚
â”‚   â”œâ”€â”€ process-content.mjs           # Ø§Ø³Ú©Ø±ÛŒÙ¾Øª Ø§ØµÙ„ÛŒ
â”‚   â””â”€â”€ watch-content.mjs             # Ù…Ø§Ù†ÛŒØªÙˆØ± ØªØºÛŒÛŒØ±Ø§Øª
â”‚
â”œâ”€â”€ .content-cache/                    # Ú©Ø´ Ø®ÙˆØ¯Ú©Ø§Ø±
â”‚   â”œâ”€â”€ configs/                      # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø³ØªØ®Ø±Ø§Ø¬â€ŒØ´Ø¯Ù‡
â”‚   â”‚   â”œâ”€â”€ transition-guide.json
â”‚   â”‚   â””â”€â”€ another-book.json
â”‚   â”œâ”€â”€ diagrams/                     # SVG Ù‡Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯Ø´Ø¯Ù‡
â”‚   â””â”€â”€ checksums.json                # Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ ØªØºÛŒÛŒØ±Ø§Øª
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ content/                      # Ø®Ø±ÙˆØ¬ÛŒ ØªÙˆÙ„ÛŒØ¯Ø´Ø¯Ù‡
â”‚   â”‚   â”œâ”€â”€ books/
â”‚   â”‚   â””â”€â”€ articles/
â”‚   â”œâ”€â”€ styles/
â”‚   â”‚   â””â”€â”€ book-themes/              # CSS Ù‡Ø± Ú©ØªØ§Ø¨ (Ø®ÙˆØ¯Ú©Ø§Ø±)
â”‚   â”‚       â”œâ”€â”€ transition-guide.css
â”‚   â”‚       â””â”€â”€ another-book.css
â”‚   â””â”€â”€ ...
â”‚
â””â”€â”€ package.json
```

---

## ğŸ§  Ù…Ø§Ú˜ÙˆÙ„ Û±: Preamble Parser

**ÙØ§ÛŒÙ„ `scripts/lib/preamble-parser.mjs`:**

```javascript
/**
 * ØªØ­Ù„ÛŒÙ„Ú¯Ø± Ù‡ÙˆØ´Ù…Ù†Ø¯ Preamble
 * Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø®ÙˆØ¯Ú©Ø§Ø± ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø² ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ LaTeX
 */

import fs from 'fs/promises';
import path from 'path';

export class PreambleParser {
  constructor() {
    // Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Regex Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬
    this.patterns = {
      // Ø±Ù†Ú¯â€ŒÙ‡Ø§
      defineColor: /\\definecolor\{(\w+)\}\{(\w+)\}\{([^}]+)\}/g,
      colorlet: /\\colorlet\{(\w+)\}\{([^}]+)\}/g,
      
      // ÙÙˆÙ†Øªâ€ŒÙ‡Ø§
      setMainFont: /\\setmainfont(?:\[([^\]]*)\])?\{([^}]+)\}/g,
      setFont: /\\set(\w+)font(?:\[([^\]]*)\])?\{([^}]+)\}/g,
      newFontFamily: /\\newfontfamily\\(\w+)(?:\[([^\]]*)\])?\{([^}]+)\}/g,
      
      // Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ TikZ
      tikzLibrary: /\\usetikzlibrary\{([^}]+)\}/g,
      pgfplotsLibrary: /\\usepgfplotslibrary\{([^}]+)\}/g,
      
      // Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ TikZ
      tikzStyle: /\\tikzstyle\{(\w+)\}\s*=\s*\[([^\]]+)\]/g,
      tikzSet: /\\tikzset\{([^}]+)\}/g,
      
      // Ù¾Ú©ÛŒØ¬â€ŒÙ‡Ø§
      usePackage: /\\usepackage(?:\[([^\]]*)\])?\{([^}]+)\}/g,
      
      // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø³ÙØ§Ø±Ø´ÛŒ
      newCommand: /\\newcommand\{\\(\w+)\}(?:\[(\d+)\])?\{([^}]+)\}/g,
      renewCommand: /\\renewcommand\{\\(\w+)\}(?:\[(\d+)\])?\{([^}]+)\}/g,
      
      // input/include
      input: /\\input\{([^}]+)\}/g,
      include: /\\include\{([^}]+)\}/g,
    };
  }

  /**
   * ØªØ­Ù„ÛŒÙ„ Ú©Ø§Ù…Ù„ ÛŒÚ© Ù¾Ø±ÙˆÚ˜Ù‡ LaTeX
   */
  async analyzeProject(projectDir) {
    console.log(`\nğŸ” ØªØ­Ù„ÛŒÙ„ Ù¾Ø±ÙˆÚ˜Ù‡: ${projectDir}`);
    
    const config = {
      projectDir,
      colors: {},
      fonts: {
        main: null,
        sans: null,
        mono: null,
        custom: {}
      },
      tikz: {
        libraries: new Set(),
        styles: {},
        pgfplotsLibraries: new Set()
      },
      packages: [],
      customCommands: {},
      dependencies: []
    };

    // ÛŒØ§ÙØªÙ† ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ
    const mainFile = await this.findMainFile(projectDir);
    if (!mainFile) {
      throw new Error(`ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ LaTeX Ø¯Ø± ${projectDir} ÛŒØ§ÙØª Ù†Ø´Ø¯`);
    }

    console.log(`   ğŸ“„ ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ: ${mainFile}`);

    // ØªØ­Ù„ÛŒÙ„ Ø¨Ø§Ø²Ú¯Ø´ØªÛŒ
    await this.parseFileRecursive(mainFile, config, new Set());

    // Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ
    config.tikz.libraries = Array.from(config.tikz.libraries);
    config.tikz.pgfplotsLibraries = Array.from(config.tikz.pgfplotsLibraries);

    console.log(`   ğŸ¨ Ø±Ù†Ú¯â€ŒÙ‡Ø§: ${Object.keys(config.colors).length}`);
    console.log(`   ğŸ”¤ ÙÙˆÙ†Øªâ€ŒÙ‡Ø§: ${Object.keys(config.fonts.custom).length + (config.fonts.main ? 1 : 0)}`);
    console.log(`   ğŸ“Š Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ TikZ: ${config.tikz.libraries.length}`);

    return config;
  }

  /**
   * ÛŒØ§ÙØªÙ† ÙØ§ÛŒÙ„ Ø§ØµÙ„ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡
   */
  async findMainFile(projectDir) {
    const candidates = [
      'main.tex',
      'book.tex', 
      'index.tex',
      'document.tex'
    ];

    // Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø³ØªÙ‚ÛŒÙ…
    for (const candidate of candidates) {
      const filePath = path.join(projectDir, candidate);
      try {
        await fs.access(filePath);
        return filePath;
      } catch {}
    }

    // Ø¬Ø³ØªØ¬ÙˆÛŒ ÙØ§ÛŒÙ„ Ø¨Ø§ \documentclass
    const texFiles = await this.findTexFiles(projectDir);
    for (const file of texFiles) {
      const content = await fs.readFile(file, 'utf-8');
      if (content.includes('\\documentclass')) {
        return file;
      }
    }

    return null;
  }

  /**
   * ÛŒØ§ÙØªÙ† Ù‡Ù…Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ .tex
   */
  async findTexFiles(dir) {
    const files = [];
    const entries = await fs.readdir(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory() && !entry.name.startsWith('.')) {
        files.push(...await this.findTexFiles(fullPath));
      } else if (entry.isFile() && entry.name.endsWith('.tex')) {
        files.push(fullPath);
      }
    }
    
    return files;
  }

  /**
   * ØªØ­Ù„ÛŒÙ„ Ø¨Ø§Ø²Ú¯Ø´ØªÛŒ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§
   */
  async parseFileRecursive(filePath, config, visited) {
    // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø­Ù„Ù‚Ù‡ Ø¨ÛŒâ€ŒÙ†Ù‡Ø§ÛŒØª
    const absPath = path.resolve(filePath);
    if (visited.has(absPath)) return;
    visited.add(absPath);

    let content;
    try {
      content = await fs.readFile(filePath, 'utf-8');
    } catch (error) {
      console.warn(`   âš ï¸ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø®ÙˆØ§Ù†Ø¯: ${filePath}`);
      return;
    }

    const baseDir = path.dirname(filePath);

    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø·Ù„Ø§Ø¹Ø§Øª
    this.extractColors(content, config);
    this.extractFonts(content, config);
    this.extractTikzConfig(content, config);
    this.extractPackages(content, config);
    this.extractCustomCommands(content, config);

    // Ù¾ÛŒÚ¯ÛŒØ±ÛŒ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ø¨Ø³ØªÙ‡
    const dependencies = this.extractDependencies(content, baseDir);
    for (const dep of dependencies) {
      config.dependencies.push(dep);
      await this.parseFileRecursive(dep, config, visited);
    }
  }

  /**
   * Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªØ¹Ø±ÛŒÙ Ø±Ù†Ú¯â€ŒÙ‡Ø§
   */
  extractColors(content, config) {
    // \definecolor{name}{model}{spec}
    let match;
    const defineColorRegex = new RegExp(this.patterns.defineColor.source, 'g');
    while ((match = defineColorRegex.exec(content)) !== null) {
      const [, name, model, spec] = match;
      config.colors[name] = this.parseColor(model, spec);
    }

    // \colorlet{name}{color}
    const colorletRegex = new RegExp(this.patterns.colorlet.source, 'g');
    while ((match = colorletRegex.exec(content)) !== null) {
      const [, name, baseColor] = match;
      config.colors[name] = { type: 'reference', base: baseColor };
    }
  }

  /**
   * ØªØ¨Ø¯ÛŒÙ„ Ø±Ù†Ú¯ LaTeX Ø¨Ù‡ CSS
   */
  parseColor(model, spec) {
    switch (model.toLowerCase()) {
      case 'rgb':
        // RGB Ø¨Ø§ Ù…Ù‚Ø§Ø¯ÛŒØ± 0-1
        const rgbParts = spec.split(',').map(v => Math.round(parseFloat(v.trim()) * 255));
        return {
          type: 'rgb',
          r: rgbParts[0],
          g: rgbParts[1],
          b: rgbParts[2],
          css: `rgb(${rgbParts.join(', ')})`
        };
      
      case 'RGB':
        // RGB Ø¨Ø§ Ù…Ù‚Ø§Ø¯ÛŒØ± 0-255
        const RGBParts = spec.split(',').map(v => parseInt(v.trim()));
        return {
          type: 'rgb',
          r: RGBParts[0],
          g: RGBParts[1],
          b: RGBParts[2],
          css: `rgb(${RGBParts.join(', ')})`
        };
      
      case 'HTML':
      case 'hex':
        return {
          type: 'hex',
          css: `#${spec.replace('#', '')}`
        };
      
      case 'cmyk':
        const cmykParts = spec.split(',').map(v => parseFloat(v.trim()));
        const rgb = this.cmykToRgb(...cmykParts);
        return {
          type: 'cmyk',
          original: spec,
          css: `rgb(${rgb.join(', ')})`
        };
      
      default:
        return { type: 'named', name: spec, css: spec };
    }
  }

  /**
   * ØªØ¨Ø¯ÛŒÙ„ CMYK Ø¨Ù‡ RGB
   */
  cmykToRgb(c, m, y, k) {
    const r = Math.round(255 * (1 - c) * (1 - k));
    const g = Math.round(255 * (1 - m) * (1 - k));
    const b = Math.round(255 * (1 - y) * (1 - k));
    return [r, g, b];
  }

  /**
   * Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙÙˆÙ†Øª
   */
  extractFonts(content, config) {
    let match;

    // \setmainfont
    const mainFontRegex = new RegExp(this.patterns.setMainFont.source, 'g');
    while ((match = mainFontRegex.exec(content)) !== null) {
      const [, options, fontName] = match;
      config.fonts.main = {
        name: fontName,
        options: this.parseOptions(options)
      };
    }

    // \setsansfont, \setmonofont
    const setFontRegex = new RegExp(this.patterns.setFont.source, 'g');
    while ((match = setFontRegex.exec(content)) !== null) {
      const [, type, options, fontName] = match;
      const key = type.toLowerCase();
      if (key === 'sans' || key === 'mono') {
        config.fonts[key] = {
          name: fontName,
          options: this.parseOptions(options)
        };
      }
    }

    // \newfontfamily
    const newFontRegex = new RegExp(this.patterns.newFontFamily.source, 'g');
    while ((match = newFontRegex.exec(content)) !== null) {
      const [, commandName, options, fontName] = match;
      config.fonts.custom[commandName] = {
        name: fontName,
        options: this.parseOptions(options)
      };
    }
  }

  /**
   * Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªÙ†Ø¸ÛŒÙ…Ø§Øª TikZ
   */
  extractTikzConfig(content, config) {
    let match;

    // Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ TikZ
    const tikzLibRegex = new RegExp(this.patterns.tikzLibrary.source, 'g');
    while ((match = tikzLibRegex.exec(content)) !== null) {
      const libs = match[1].split(',').map(l => l.trim());
      libs.forEach(lib => config.tikz.libraries.add(lib));
    }

    // Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ pgfplots
    const pgfLibRegex = new RegExp(this.patterns.pgfplotsLibrary.source, 'g');
    while ((match = pgfLibRegex.exec(content)) !== null) {
      const libs = match[1].split(',').map(l => l.trim());
      libs.forEach(lib => config.tikz.pgfplotsLibraries.add(lib));
    }

    // Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ TikZ - Ø±ÙˆØ´ Ù‚Ø¯ÛŒÙ…ÛŒ
    const tikzStyleRegex = new RegExp(this.patterns.tikzStyle.source, 'g');
    while ((match = tikzStyleRegex.exec(content)) !== null) {
      const [, name, definition] = match;
      config.tikz.styles[name] = definition;
    }

    // \tikzset
    const tikzSetRegex = new RegExp(this.patterns.tikzSet.source, 'g');
    while ((match = tikzSetRegex.exec(content)) !== null) {
      const definitions = match[1];
      this.parseTikzSet(definitions, config.tikz.styles);
    }
  }

  /**
   * ØªØ­Ù„ÛŒÙ„ \tikzset
   */
  parseTikzSet(definitions, styles) {
    // ØªØ­Ù„ÛŒÙ„ Ø³Ø§Ø¯Ù‡ - Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù¾ÛŒÚ†ÛŒØ¯Ù‡â€ŒØªØ± Ú©Ø±Ø¯
    const styleRegex = /(\w+)\/\.style\s*=\s*\{([^}]+)\}/g;
    let match;
    while ((match = styleRegex.exec(definitions)) !== null) {
      styles[match[1]] = match[2];
    }
  }

  /**
   * Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù¾Ú©ÛŒØ¬â€ŒÙ‡Ø§
   */
  extractPackages(content, config) {
    const packageRegex = new RegExp(this.patterns.usePackage.source, 'g');
    let match;
    while ((match = packageRegex.exec(content)) !== null) {
      const [, options, packages] = match;
      const pkgList = packages.split(',').map(p => p.trim());
      for (const pkg of pkgList) {
        config.packages.push({
          name: pkg,
          options: options ? options.split(',').map(o => o.trim()) : []
        });
      }
    }
  }

  /**
   * Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¯Ø³ØªÙˆØ±Ø§Øª Ø³ÙØ§Ø±Ø´ÛŒ
   */
  extractCustomCommands(content, config) {
    const patterns = [this.patterns.newCommand, this.patterns.renewCommand];
    
    for (const pattern of patterns) {
      const regex = new RegExp(pattern.source, 'g');
      let match;
      while ((match = regex.exec(content)) !== null) {
        const [, name, numArgs, definition] = match;
        config.customCommands[name] = {
          args: numArgs ? parseInt(numArgs) : 0,
          definition: definition
        };
      }
    }
  }

  /**
   * Ø§Ø³ØªØ®Ø±Ø§Ø¬ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒâ€ŒÙ‡Ø§
   */
  extractDependencies(content, baseDir) {
    const deps = [];
    const patterns = [this.patterns.input, this.patterns.include];
    
    for (const pattern of patterns) {
      const regex = new RegExp(pattern.source, 'g');
      let match;
      while ((match = regex.exec(content)) !== null) {
        let depPath = match[1];
        if (!depPath.endsWith('.tex')) {
          depPath += '.tex';
        }
        deps.push(path.resolve(baseDir, depPath));
      }
    }
    
    return deps;
  }

  /**
   * ØªØ­Ù„ÛŒÙ„ options
   */
  parseOptions(optionsStr) {
    if (!optionsStr) return {};
    
    const options = {};
    const parts = optionsStr.split(',');
    
    for (const part of parts) {
      const [key, value] = part.split('=').map(s => s.trim());
      options[key] = value || true;
    }
    
    return options;
  }
}

export default PreambleParser;
```

---

## ğŸ¨ Ù…Ø§Ú˜ÙˆÙ„ Û²: CSS Generator

**ÙØ§ÛŒÙ„ `scripts/lib/style-generator.mjs`:**

```javascript
/**
 * ØªÙˆÙ„ÛŒØ¯Ú©Ù†Ù†Ø¯Ù‡ Ø®ÙˆØ¯Ú©Ø§Ø± CSS Ø§Ø² ØªÙ†Ø¸ÛŒÙ…Ø§Øª LaTeX
 */

import fs from 'fs/promises';
import path from 'path';

export class StyleGenerator {
  constructor(outputDir = 'src/styles/book-themes') {
    this.outputDir = outputDir;
  }

  /**
   * ØªÙˆÙ„ÛŒØ¯ ÙØ§ÛŒÙ„ CSS Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©ØªØ§Ø¨
   */
  async generateCSS(config, bookSlug) {
    const css = this.buildCSS(config, bookSlug);
    
    await fs.mkdir(this.outputDir, { recursive: true });
    const outputPath = path.join(this.outputDir, `${bookSlug}.css`);
    await fs.writeFile(outputPath, css, 'utf-8');
    
    console.log(`   ğŸ¨ CSS ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯: ${outputPath}`);
    return outputPath;
  }

  /**
   * Ø³Ø§Ø®Øª Ù…Ø­ØªÙˆØ§ÛŒ CSS
   */
  buildCSS(config, bookSlug) {
    const lines = [];
    
    lines.push(`/**`);
    lines.push(` * ØªÙ… Ø®ÙˆØ¯Ú©Ø§Ø± ØªÙˆÙ„ÛŒØ¯Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ: ${bookSlug}`);
    lines.push(` * ØªØ§Ø±ÛŒØ®: ${new Date().toISOString()}`);
    lines.push(` */\n`);

    // CSS Variables Ø¨Ø±Ø§ÛŒ Ø±Ù†Ú¯â€ŒÙ‡Ø§
    lines.push(`/* â•â•â• Ø±Ù†Ú¯â€ŒÙ‡Ø§ â•â•â• */`);
    lines.push(`.book-${bookSlug} {`);
    
    for (const [name, color] of Object.entries(config.colors)) {
      if (color.css) {
        lines.push(`  --color-${this.kebabCase(name)}: ${color.css};`);
      }
    }
    
    // ÙÙˆÙ†Øªâ€ŒÙ‡Ø§
    lines.push(`\n  /* ÙÙˆÙ†Øªâ€ŒÙ‡Ø§ */`);
    if (config.fonts.main) {
      lines.push(`  --font-main: '${config.fonts.main.name}', serif;`);
    }
    if (config.fonts.sans) {
      lines.push(`  --font-sans: '${config.fonts.sans.name}', sans-serif;`);
    }
    if (config.fonts.mono) {
      lines.push(`  --font-mono: '${config.fonts.mono.name}', monospace;`);
    }
    
    lines.push(`}\n`);

    // Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ TikZ Ø¨Ù‡ Ú©Ù„Ø§Ø³ CSS
    lines.push(`/* â•â•â• Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆØ¯Ø§Ø± â•â•â• */`);
    for (const [styleName, definition] of Object.entries(config.tikz.styles)) {
      lines.push(this.tikzStyleToCSS(styleName, definition, bookSlug));
    }

    // Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡
    lines.push(`\n/* â•â•â• Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡ â•â•â• */`);
    lines.push(this.generateBaseStyles(bookSlug));

    return lines.join('\n');
  }

  /**
   * ØªØ¨Ø¯ÛŒÙ„ Ø§Ø³ØªØ§ÛŒÙ„ TikZ Ø¨Ù‡ CSS
   */
  tikzStyleToCSS(name, definition, bookSlug) {
    // ØªØ¨Ø¯ÛŒÙ„ Ø³Ø§Ø¯Ù‡ - Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù¾ÛŒÚ†ÛŒØ¯Ù‡â€ŒØªØ± Ú©Ø±Ø¯
    const cssProps = [];
    
    // fill
    const fillMatch = definition.match(/fill=([^,\]]+)/);
    if (fillMatch) {
      const color = fillMatch[1].trim();
      cssProps.push(`  background-color: var(--color-${this.kebabCase(color)}, ${color});`);
    }
    
    // draw
    const drawMatch = definition.match(/draw=([^,\]]+)/);
    if (drawMatch) {
      const color = drawMatch[1].trim();
      cssProps.push(`  border-color: var(--color-${this.kebabCase(color)}, ${color});`);
    }
    
    // rounded corners
    if (definition.includes('rounded corners')) {
      const radiusMatch = definition.match(/rounded corners=(\d+)pt/);
      const radius = radiusMatch ? radiusMatch[1] : '8';
      cssProps.push(`  border-radius: ${radius}px;`);
    }
    
    if (cssProps.length === 0) return '';
    
    return `.book-${bookSlug} .tikz-style-${this.kebabCase(name)} {\n${cssProps.join('\n')}\n}\n`;
  }

  /**
   * Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡
   */
  generateBaseStyles(bookSlug) {
    return `
.book-${bookSlug} {
  font-family: var(--font-main, 'Vazirmatn', serif);
}

.book-${bookSlug} h1,
.book-${bookSlug} h2,
.book-${bookSlug} h3 {
  font-family: var(--font-main, 'Vazirmatn', serif);
}

.book-${bookSlug} code,
.book-${bookSlug} pre {
  font-family: var(--font-mono, 'Fira Code', monospace);
}

.book-${bookSlug} .tikz-diagram {
  max-width: 100%;
  height: auto;
  margin: 2rem auto;
  display: block;
}

.book-${bookSlug} figure.tikz-figure {
  text-align: center;
  margin: 2rem 0;
}

.book-${bookSlug} figure.tikz-figure figcaption {
  font-size: 0.9rem;
  color: var(--color-gris, #666);
  margin-top: 0.5rem;
}
`;
  }

  /**
   * ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ kebab-case
   */
  kebabCase(str) {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/[_\s]+/g, '-')
      .toLowerCase();
  }
}

export default StyleGenerator;
```

---

## ğŸ”§ Ù…Ø§Ú˜ÙˆÙ„ Û³: Smart Renderer

**ÙØ§ÛŒÙ„ `scripts/lib/smart-renderer.mjs`:**

```javascript
/**
 * Ø±Ù†Ø¯Ø±Ø± Ù‡ÙˆØ´Ù…Ù†Ø¯ TikZ Ø¨Ø§ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÙˆÛŒØ§
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';

const execAsync = promisify(exec);

export class SmartRenderer {
  constructor(options = {}) {
    this.tempDir = options.tempDir || path.join(process.env.TEMP || '/tmp', 'smart-renderer');
    this.outputDir = options.outputDir || 'public/diagrams';
    this.cacheDir = options.cacheDir || '.content-cache/diagrams';
    this.isWindows = process.platform === 'win32';
    
    this.stats = {
      rendered: 0,
      cached: 0,
      failed: 0
    };
  }

  /**
   * Ø³Ø§Ø®Øª Template Ù¾ÙˆÛŒØ§ Ø¨Ø± Ø§Ø³Ø§Ø³ config
   */
  buildDynamicTemplate(tikzCode, config) {
    const lines = [];
    
    // Document class
    lines.push('\\documentclass[tikz,border=15pt]{standalone}');
    lines.push('');
    
    // Ù¾Ú©ÛŒØ¬â€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡
    lines.push('\\usepackage{fontspec}');
    lines.push('\\usepackage{xcolor}');
    lines.push('\\usepackage{tikz}');
    lines.push('\\usepackage{pgfplots}');
    lines.push('\\pgfplotsset{compat=1.18}');
    lines.push('');
    
    // Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ TikZ - Ø§Ø² config
    if (config.tikz.libraries.length > 0) {
      lines.push(`\\usetikzlibrary{${config.tikz.libraries.join(',')}}`);
    }
    if (config.tikz.pgfplotsLibraries.length > 0) {
      lines.push(`\\usepgfplotslibrary{${config.tikz.pgfplotsLibraries.join(',')}}`);
    }
    lines.push('');
    
    // ÙÙˆÙ†Øª - Ø§Ø² config
    if (config.fonts.main) {
      const fontName = config.fonts.main.name;
      const options = config.fonts.main.options;
      const optStr = Object.entries(options)
        .map(([k, v]) => v === true ? k : `${k}=${v}`)
        .join(',');
      lines.push(`\\setmainfont${optStr ? `[${optStr}]` : ''}{${fontName}}`);
    } else {
      lines.push('\\setmainfont{Vazirmatn}');
    }
    lines.push('');
    
    // Ø±Ù†Ú¯â€ŒÙ‡Ø§ - Ø§Ø² config
    lines.push('% Ø±Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡');
    for (const [name, color] of Object.entries(config.colors)) {
      if (color.type === 'rgb') {
        lines.push(`\\definecolor{${name}}{RGB}{${color.r},${color.g},${color.b}}`);
      } else if (color.type === 'hex') {
        lines.push(`\\definecolor{${name}}{HTML}{${color.css.replace('#', '')}}`);
      } else if (color.type === 'reference') {
        lines.push(`\\colorlet{${name}}{${color.base}}`);
      }
    }
    lines.push('');
    
    // Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ TikZ - Ø§Ø² config
    if (Object.keys(config.tikz.styles).length > 0) {
      lines.push('% Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ TikZ');
      lines.push('\\tikzset{');
      const styleEntries = Object.entries(config.tikz.styles);
      styleEntries.forEach(([name, def], i) => {
        const comma = i < styleEntries.length - 1 ? ',' : '';
        lines.push(`  ${name}/.style={${def}}${comma}`);
      });
      lines.push('}');
    }
    lines.push('');
    
    // Document
    lines.push('\\begin{document}');
    lines.push(tikzCode);
    lines.push('\\end{document}');
    
    return lines.join('\n');
  }

  /**
   * Ø±Ù†Ø¯Ø± TikZ Ø¨Ù‡ SVG
   */
  async render(tikzCode, config, options = {}) {
    const { name = 'diagram', forceRender = false } = options;
    
    // ØªÙˆÙ„ÛŒØ¯ hash ÛŒÚ©ØªØ§
    const contentHash = crypto
      .createHash('md5')
      .update(tikzCode + JSON.stringify(config.colors) + JSON.stringify(config.tikz))
      .digest('hex')
      .slice(0, 12);
    
    const outputName = `${name}-${contentHash}`;
    const svgPath = path.join(this.outputDir, `${outputName}.svg`);
    
    // Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø´
    if (!forceRender) {
      try {
        await fs.access(svgPath);
        this.stats.cached++;
        console.log(`   âš¡ Ú©Ø´: ${outputName}`);
        return { success: true, path: svgPath, cached: true };
      } catch {}
    }
    
    // Ø³Ø§Ø®Øª Ø¯Ø§ÛŒØ±Ú©ØªÙˆØ±ÛŒâ€ŒÙ‡Ø§
    await fs.mkdir(this.tempDir, { recursive: true });
    await fs.mkdir(this.outputDir, { recursive: true });
    
    // Ø³Ø§Ø®Øª template Ù¾ÙˆÛŒØ§
    const texContent = this.buildDynamicTemplate(tikzCode, config);
    const texFile = path.join(this.tempDir, `${outputName}.tex`);
    const pdfFile = path.join(this.tempDir, `${outputName}.pdf`);
    
    try {
      // Ù†ÙˆØ´ØªÙ† ÙØ§ÛŒÙ„
      await fs.writeFile(texFile, texContent, 'utf-8');
      
      // Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„
      console.log(`   ğŸ”„ Ø±Ù†Ø¯Ø±: ${outputName}...`);
      
      const compileCmd = this.isWindows
        ? `cd /d "${this.tempDir}" && xelatex -interaction=nonstopmode -halt-on-error "${outputName}.tex"`
        : `cd "${this.tempDir}" && xelatex -interaction=nonstopmode -halt-on-error "${outputName}.tex"`;
      
      await execAsync(compileCmd, {
        timeout: 120000,
        shell: this.isWindows ? 'cmd.exe' : '/bin/sh'
      });
      
      // PDF â†’ SVG
      await this.convertToSVG(pdfFile, svgPath);
      
      // Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ
      await this.optimizeSVG(svgPath, outputName);
      
      this.stats.rendered++;
      console.log(`   âœ… ØªÙˆÙ„ÛŒØ¯: ${outputName}`);
      
      return { success: true, path: svgPath, cached: false };
      
    } catch (error) {
      this.stats.failed++;
      console.error(`   âŒ Ø®Ø·Ø§: ${outputName}`);
      
      // Ø°Ø®ÛŒØ±Ù‡ Ù„Ø§Ú¯ Ø®Ø·Ø§
      await this.saveErrorLog(outputName, error);
      
      return { success: false, error: error.message };
    }
  }

  /**
   * ØªØ¨Ø¯ÛŒÙ„ PDF Ø¨Ù‡ SVG
   */
  async convertToSVG(pdfPath, svgPath) {
    if (this.isWindows) {
      // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Inkscape Ø¯Ø± ÙˆÛŒÙ†Ø¯ÙˆØ²
      await execAsync(
        `inkscape "${pdfPath}" --export-filename="${svgPath}" --export-type=svg`,
        { timeout: 60000 }
      );
    } else {
      // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² pdf2svg Ø¯Ø± Ù„ÛŒÙ†ÙˆÚ©Ø³/Ù…Ú©
      await execAsync(`pdf2svg "${pdfPath}" "${svgPath}"`);
    }
  }

  /**
   * Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ SVG
   */
  async optimizeSVG(svgPath, name) {
    let content = await fs.readFile(svgPath, 'utf-8');
    
    content = content
      // Ø­Ø°Ù Ú©Ø§Ù…Ù†Øªâ€ŒÙ‡Ø§
      .replace(/<!--[\s\S]*?-->/g, '')
      // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú©Ù„Ø§Ø³
      .replace('<svg', `<svg class="tikz-diagram" id="${name}"`)
      // Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Dark mode
      .replace('</svg>', `
<style>
  @media (prefers-color-scheme: dark) {
    #${name} { filter: invert(0.88) hue-rotate(180deg); }
  }
</style>
</svg>`);
    
    await fs.writeFile(svgPath, content, 'utf-8');
  }

  /**
   * Ø°Ø®ÛŒØ±Ù‡ Ù„Ø§Ú¯ Ø®Ø·Ø§
   */
  async saveErrorLog(name, error) {
    const logDir = path.join(this.cacheDir, 'errors');
    await fs.mkdir(logDir, { recursive: true });
    
    const logContent = {
      name,
      timestamp: new Date().toISOString(),
      error: error.message,
      stack: error.stack
    };
    
    await fs.writeFile(
      path.join(logDir, `${name}.json`),
      JSON.stringify(logContent, null, 2)
    );
  }

  /**
   * Ú¯Ø²Ø§Ø±Ø´ Ø¢Ù…Ø§Ø±
   */
  getStats() {
    return {
      ...this.stats,
      total: this.stats.rendered + this.stats.cached + this.stats.failed
    };
  }
}

export default SmartRenderer;
```

---

## ğŸš€ Ø§Ø³Ú©Ø±ÛŒÙ¾Øª Ø§ØµÙ„ÛŒ ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡

**ÙØ§ÛŒÙ„ `scripts/process-content.mjs`:**

```javascript
#!/usr/bin/env node
/**
 * Ø³ÛŒØ³ØªÙ… Ø®ÙˆØ¯Ú©Ø§Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù…Ø­ØªÙˆØ§
 * ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´Ù…Ù†Ø¯ØŒ ØªØ¨Ø¯ÛŒÙ„ Ùˆ ØªÙˆÙ„ÛŒØ¯ Ø®Ø±ÙˆØ¬ÛŒ ÙˆØ¨
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { globby } from 'globby';

import { PreambleParser } from './lib/preamble-parser.mjs';
import { StyleGenerator } from './lib/style-generator.mjs';
import { SmartRenderer } from './lib/smart-renderer.mjs';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ØªÙ†Ø¸ÛŒÙ…Ø§Øª
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CONFIG = {
  sourceDir: 'content-source',
  outputDir: 'src/content',
  cacheDir: '.content-cache',
  stylesDir: 'src/styles/book-themes',
  diagramsDir: 'public/diagrams'
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ú©Ù„Ø§Ø³ Ø§ØµÙ„ÛŒ Pipeline
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ContentPipeline {
  constructor() {
    this.parser = new PreambleParser();
    this.styleGen = new StyleGenerator(CONFIG.stylesDir);
    this.renderer = new SmartRenderer({
      outputDir: CONFIG.diagramsDir,
      cacheDir: CONFIG.cacheDir
    });
    
    this.configCache = new Map();
  }

  /**
   * Ù¾Ø±Ø¯Ø§Ø²Ø´ ÛŒÚ© Ú©ØªØ§Ø¨
   */
  async processBook(bookDir, options = {}) {
    const { lang = 'fa', slug } = options;
    const bookSlug = slug || path.basename(bookDir);
    
    console.log(`\n${'â•'.repeat(60)}`);
    console.log(`ğŸ“š Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©ØªØ§Ø¨: ${bookSlug}`);
    console.log(`${'â•'.repeat(60)}`);
    
    // Û±. ØªØ­Ù„ÛŒÙ„ Ù¾Ø±ÙˆÚ˜Ù‡
    console.log('\nğŸ“‹ Ù…Ø±Ø­Ù„Ù‡ Û±: ØªØ­Ù„ÛŒÙ„ Ù¾Ø±ÙˆÚ˜Ù‡...');
    const config = await this.parser.analyzeProject(bookDir);
    
    // Ø°Ø®ÛŒØ±Ù‡ config Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¨Ø¹Ø¯ÛŒ
    await this.saveConfig(bookSlug, config);
    this.configCache.set(bookSlug, config);
    
    // Û². ØªÙˆÙ„ÛŒØ¯ CSS
    console.log('\nğŸ¨ Ù…Ø±Ø­Ù„Ù‡ Û²: ØªÙˆÙ„ÛŒØ¯ CSS...');
    await this.styleGen.generateCSS(config, bookSlug);
    
    // Û³. ÛŒØ§ÙØªÙ† ÙØµÙ„â€ŒÙ‡Ø§
    const chapters = await this.findChapters(bookDir);
    console.log(`\nğŸ“‘ ÛŒØ§ÙØª Ø´Ø¯: ${chapters.length} ÙØµÙ„`);
    
    // Û´. Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù‡Ø± ÙØµÙ„
    const outputDir = path.join(CONFIG.outputDir, 'books', lang, bookSlug);
    await fs.mkdir(outputDir, { recursive: true });
    
    for (let i = 0; i < chapters.length; i++) {
      await this.processChapter(chapters[i], {
        config,
        bookSlug,
        chapterNumber: i + 1,
        outputDir,
        lang
      });
    }
    
    // Ûµ. Ø§ÛŒØ¬Ø§Ø¯ index
    await this.generateBookIndex(bookSlug, chapters, outputDir, lang);
    
    // Û¶. Ú¯Ø²Ø§Ø±Ø´
    const stats = this.renderer.getStats();
    console.log(`\nâœ… Ú©ØªØ§Ø¨ ${bookSlug} Ú©Ø§Ù…Ù„ Ø´Ø¯!`);
    console.log(`   ğŸ“Š Ù†Ù…ÙˆØ¯Ø§Ø±Ù‡Ø§: ${stats.rendered} Ø±Ù†Ø¯Ø±ØŒ ${stats.cached} Ú©Ø´ØŒ ${stats.failed} Ø®Ø·Ø§`);
    
    return { bookSlug, chapters: chapters.length, stats };
  }

  /**
   * ÛŒØ§ÙØªÙ† ÙØµÙ„â€ŒÙ‡Ø§ÛŒ Ú©ØªØ§Ø¨
   */
  async findChapters(bookDir) {
    const patterns = [
      path.join(bookDir, 'chapters', '*.tex'),
      path.join(bookDir, 'ch*.tex'),
      path.join(bookDir, 'chapter*.tex'),
      path.join(bookDir, 'ÙØµÙ„*.tex')
    ];
    
    let chapters = await globby(patterns);
    
    // Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ
    chapters.sort((a, b) => {
      const numA = parseInt(path.basename(a).match(/\d+/)?.[0] || '0');
      const numB = parseInt(path.basename(b).match(/\d+/)?.[0] || '0');
      return numA - numB;
    });
    
    return chapters;
  }

  /**
   * Ù¾Ø±Ø¯Ø§Ø²Ø´ ÛŒÚ© ÙØµÙ„
   */
  async processChapter(chapterPath, options) {
    const { config, bookSlug, chapterNumber, outputDir, lang } = options;
    
    console.log(`\n   ğŸ“„ ÙØµÙ„ ${chapterNumber}: ${path.basename(chapterPath)}`);
    
    // Ø®ÙˆØ§Ù†Ø¯Ù† Ù…Ø­ØªÙˆØ§
    let content = await fs.readFile(chapterPath, 'utf-8');
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ùˆ Ø±Ù†Ø¯Ø± Ù†Ù…ÙˆØ¯Ø§Ø±Ù‡Ø§
    content = await this.processAllDiagrams(content, config, `${bookSlug}-ch${chapterNumber}`);
    
    // Ù¾ÛŒØ´â€ŒÙ¾Ø±Ø¯Ø§Ø²Ø´
    content = this.preProcess(content);
    
    // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ø§ Pandoc
    const markdown = await this.convertWithPandoc(content);
    
    // Ù¾Ø³â€ŒÙ¾Ø±Ø¯Ø§Ø²Ø´
    const finalMd = this.postProcess(markdown, { bookSlug, chapterNumber, lang });
    
    // Ø°Ø®ÛŒØ±Ù‡
    const outputFileName = `ch${String(chapterNumber).padStart(2, '0')}-${path.basename(chapterPath, '.tex')}.md`;
    const outputPath = path.join(outputDir, outputFileName);
    await fs.writeFile(outputPath, finalMd, 'utf-8');
    
    console.log(`      âœ… ${outputFileName}`);
  }

  /**
   * Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù‡Ù…Ù‡ Ù†Ù…ÙˆØ¯Ø§Ø±Ù‡Ø§
   */
  async processAllDiagrams(content, config, prefix) {
    const tikzRegex = /\\begin\{tikzpicture\}(\[[\s\S]*?\])?([\s\S]*?)\\end\{tikzpicture\}/g;
    
    const matches = [...content.matchAll(tikzRegex)];
    console.log(`      ğŸ“Š Ù†Ù…ÙˆØ¯Ø§Ø±Ù‡Ø§: ${matches.length}`);
    
    let counter = 0;
    for (const match of matches) {
      counter++;
      const tikzCode = match[0];
      const name = `${prefix}-${counter}`;
      
      const result = await this.renderer.render(tikzCode, config, { name });
      
      if (result.success) {
        const relativePath = `/diagrams/${path.basename(result.path)}`;
        const replacement = `\n\n![Ù†Ù…ÙˆØ¯Ø§Ø± ${counter}](${relativePath}){.tikz-diagram}\n\n`;
        content = content.replace(tikzCode, replacement);
      } else {
        content = content.replace(tikzCode, `\n\n<!-- DIAGRAM_ERROR: ${name} -->\n\n`);
      }
    }
    
    return content;
  }

  /**
   * Ù¾ÛŒØ´â€ŒÙ¾Ø±Ø¯Ø§Ø²Ø´
   */
  preProcess(content) {
    return content
      // ØªØ¨Ø¯ÛŒÙ„ tcolorbox
      .replace(
        /\\begin\{tcolorbox\}\[([^\]]*title=\{([^}]*)\}[^\]]*)\]([\s\S]*?)\\end\{tcolorbox\}/g,
        (_, opts, title, body) => `\n\n> **${title}**\n> ${body.trim().replace(/\n/g, '\n> ')}\n\n`
      )
      // Ø­Ø°Ù Ú©Ø§Ù…Ù†Ø¯Ù‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ
      .replace(/\\renewcommand\{[^}]*\}\{[^}]*\}/g, '')
      .replace(/\\setcounter\{[^}]*\}\{[^}]*\}/g, '');
  }

  /**
   * ØªØ¨Ø¯ÛŒÙ„ Ø¨Ø§ Pandoc
   */
  async convertWithPandoc(content) {
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const execAsync = promisify(exec);
    
    const tempDir = path.join(CONFIG.cacheDir, 'temp');
    await fs.mkdir(tempDir, { recursive: true });
    
    const inputFile = path.join(tempDir, 'input.tex');
    const outputFile = path.join(tempDir, 'output.md');
    
    await fs.writeFile(inputFile, content, 'utf-8');
    
    const cmd = `pandoc "${inputFile}" -o "${outputFile}" --wrap=none --columns=1000`;
    await execAsync(cmd, { timeout: 60000 });
    
    return fs.readFile(outputFile, 'utf-8');
  }

  /**
   * Ù¾Ø³â€ŒÙ¾Ø±Ø¯Ø§Ø²Ø´
   */
  postProcess(markdown, options) {
    const { bookSlug, chapterNumber, lang } = options;
    
    // Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ
    let result = markdown
      .replace(/\[node distance[\s\S]*?(?=\n\n|\n#|$)/g, '')
      .replace(/\\node[\s\S]*?;/g, '')
      .replace(/\\draw[\s\S]*?;/g, '')
      .replace(/\n{3,}/g, '\n\n')
      .trim();
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¹Ù†ÙˆØ§Ù†
    const titleMatch = result.match(/^#\s+(.+)$/m);
    const title = titleMatch ? titleMatch[1] : `ÙØµÙ„ ${chapterNumber}`;
    
    // Frontmatter
    const frontmatter = `---
title: "${title}"
description: "${title}"
lang: ${lang}
chapterNumber: ${chapterNumber}
book: "${bookSlug}"
---

`;
    
    return frontmatter + result;
  }

  /**
   * Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
   */
  async saveConfig(bookSlug, config) {
    const configDir = path.join(CONFIG.cacheDir, 'configs');
    await fs.mkdir(configDir, { recursive: true });
    
    await fs.writeFile(
      path.join(configDir, `${bookSlug}.json`),
      JSON.stringify(config, null, 2),
      'utf-8'
    );
  }

  /**
   * Ø§ÛŒØ¬Ø§Ø¯ index Ú©ØªØ§Ø¨
   */
  async generateBookIndex(bookSlug, chapters, outputDir, lang) {
    const content = `---
title: "${bookSlug}"
description: "ÙÙ‡Ø±Ø³Øª ÙØµÙˆÙ„"
lang: ${lang}
---

# ÙÙ‡Ø±Ø³Øª ÙØµÙˆÙ„

${chapters.map((ch, i) => {
  const baseName = path.basename(ch, '.tex');
  return `${i + 1}. [ÙØµÙ„ ${i + 1}](./ch${String(i + 1).padStart(2, '0')}-${baseName})`;
}).join('\n')}
`;
    
    await fs.writeFile(path.join(outputDir, 'index.md'), content, 'utf-8');
  }

  /**
   * Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù‡Ù…Ù‡ Ù…Ø­ØªÙˆØ§
   */
  async processAll() {
    console.log('ğŸš€ Ø´Ø±ÙˆØ¹ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù‡Ù…Ù‡ Ù…Ø­ØªÙˆØ§...\n');
    
    // ÛŒØ§ÙØªÙ† Ú©ØªØ§Ø¨â€ŒÙ‡Ø§
    const bookDirs = await globby(path.join(CONFIG.sourceDir, 'books', '*'), {
      onlyDirectories: true
    });
    
    console.log(`ğŸ“š ÛŒØ§ÙØª Ø´Ø¯: ${bookDirs.length} Ú©ØªØ§Ø¨\n`);
    
    const results = [];
    for (const bookDir of bookDirs) {
      try {
        const result = await this.processBook(bookDir);
        results.push(result);
      } catch (error) {
        console.error(`âŒ Ø®Ø·Ø§ Ø¯Ø± ${path.basename(bookDir)}:`, error.message);
      }
    }
    
    // Ú¯Ø²Ø§Ø±Ø´ Ù†Ù‡Ø§ÛŒÛŒ
    console.log('\n' + 'â•'.repeat(60));
    console.log('ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ù†Ù‡Ø§ÛŒÛŒ:');
    console.log('â•'.repeat(60));
    results.forEach(r => {
      console.log(`   ğŸ“š ${r.bookSlug}: ${r.chapters} ÙØµÙ„`);
    });
    
    return results;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function main() {
  const args = process.argv.slice(2);
  const pipeline = new ContentPipeline();
  
  if (args.length === 0 || args.includes('--all')) {
    await pipeline.processAll();
  } else if (args.includes('--book')) {
    const bookDir = args[args.indexOf('--book') + 1];
    const slug = args.find(a => a.startsWith('--slug='))?.split('=')[1];
    const lang = args.find(a => a.startsWith('--lang='))?.split('=')[1] || 'fa';
    
    await pipeline.processBook(bookDir, { slug, lang });
  } else {
    console.log(`
ğŸ“˜ Ø±Ø§Ù‡Ù†Ù…Ø§:

  Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù‡Ù…Ù‡:
    node scripts/process-content.mjs --all
  
  Ù¾Ø±Ø¯Ø§Ø²Ø´ ÛŒÚ© Ú©ØªØ§Ø¨:
    node scripts/process-content.mjs --book content-source/books/my-book --slug=my-book --lang=fa
`);
  }
}

main().catch(console.error);

export { ContentPipeline };
```

---

## ğŸ“¦ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ package.json

```json
{
  "name": "your-site",
  "type": "module",
  "scripts": {
    "dev": "astro dev",
    "build": "npm run content:all && astro build",
    "preview": "astro preview",
    
    "content:all": "node scripts/process-content.mjs --all",
    "content:book": "node scripts/process-content.mjs --book",
    "content:watch": "node scripts/watch-content.mjs",
    
    "clean": "rm -rf .content-cache public/diagrams src/styles/book-themes"
  },
  "devDependencies": {
    "globby": "^14.0.0",
    "gray-matter": "^4.0.3",
    "chokidar": "^3.5.3"
  }
}
```

---

## ğŸ¯ Ø®Ù„Ø§ØµÙ‡ Ø±Ø§Ù‡â€ŒØ­Ù„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Ø³ÛŒØ³ØªÙ… Ù‡ÙˆØ´Ù…Ù†Ø¯ - Ú†Ú¯ÙˆÙ†Ù‡ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯ØŸ                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  Û±. ØªØ­Ù„ÛŒÙ„ Ø®ÙˆØ¯Ú©Ø§Ø±:                                                â”‚
â”‚     â€¢ Ø®ÙˆØ§Ù†Ø¯Ù† main.tex Ùˆ preamble.tex                            â”‚
â”‚     â€¢ Ø§Ø³ØªØ®Ø±Ø§Ø¬ \definecolor â†’ Ø±Ù†Ú¯â€ŒÙ‡Ø§ÛŒ CSS                        â”‚
â”‚     â€¢ Ø§Ø³ØªØ®Ø±Ø§Ø¬ \setmainfont â†’ ÙÙˆÙ†Øªâ€ŒÙ‡Ø§                            â”‚
â”‚     â€¢ Ø§Ø³ØªØ®Ø±Ø§Ø¬ \tikzstyle â†’ Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆØ¯Ø§Ø±                    â”‚
â”‚     â€¢ Ø§Ø³ØªØ®Ø±Ø§Ø¬ \usetikzlibrary â†’ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù„Ø§Ø²Ù…              â”‚
â”‚                                                                   â”‚
â”‚  Û². ØªÙˆÙ„ÛŒØ¯ Ù¾ÙˆÛŒØ§:                                                  â”‚
â”‚     â€¢ CSS Variables Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ú©ØªØ§Ø¨                                â”‚
â”‚     â€¢ Template Ø§Ø®ØªØµØ§ØµÛŒ Ø¨Ø±Ø§ÛŒ Ø±Ù†Ø¯Ø± TikZ                          â”‚
â”‚                                                                   â”‚
â”‚  Û³. Ú©Ø´ Ù‡ÙˆØ´Ù…Ù†Ø¯:                                                   â”‚
â”‚     â€¢ Ù†Ù…ÙˆØ¯Ø§Ø±Ù‡Ø§ÛŒ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø±Ù†Ø¯Ø± Ù†Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯                 â”‚
â”‚     â€¢ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡Ø± Ú©ØªØ§Ø¨ Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯                              â”‚
â”‚                                                                   â”‚
â”‚  Û´. ÛŒÚ© Ø¯Ø³ØªÙˆØ± Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡:                                          â”‚
â”‚     npm run content:all                                          â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯:
1. **Ø§Ø³Ú©Ø±ÛŒÙ¾Øª watch** Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø®ÙˆØ¯Ú©Ø§Ø± ØªØºÛŒÛŒØ±Ø§ØªØŸ
2. **Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² PDF** ÙˆØ±ÙˆØ¯ÛŒØŸ
3. **ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø§ AI** Ø¨Ø±Ø§ÛŒ ØªÚ¯â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±ØŸ