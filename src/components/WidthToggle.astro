---
interface Props {
  title: string;
  author?: string;
  lang: 'fa' | 'en';
}

const { title, author = '', lang } = Astro.props;
const isArabic = lang === 'fa';
---

<header
  class="floating-header"
  id="width-toggle-header"
  aria-hidden="true"
>
  <div class="floating-header-content" id="floating-header-content">
    <!-- Info Section -->
    <div class="header-info">
      <h2 class="header-title">{title}</h2>
      {author && <p class="header-author">{author}</p>}
    </div>

    <!-- Width Options -->
    <div class="width-options">
      <button
        class="width-btn"
        data-width="default"
        title={isArabic ? 'عرض عادی' : 'Comfortable reading'}
      >
        <!-- Narrow column icon -->
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="6" y="3" width="12" height="18" rx="1" />
        </svg>
        <span class="btn-label">S</span>
      </button>
      <button
        class="width-btn"
        data-width="1024"
        title={isArabic ? 'عرض متوسط' : 'Medium width'}
      >
        <!-- Medium column icon -->
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="4" y="3" width="16" height="18" rx="1" />
        </svg>
        <span class="btn-label">M</span>
      </button>
      <button
        class="width-btn"
        data-width="1280"
        title={isArabic ? 'عرض بزرگ' : 'Wide view'}
      >
        <!-- Wide column icon -->
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="2" y="3" width="20" height="18" rx="1" />
        </svg>
        <span class="btn-label">L</span>
      </button>
      <button
        class="width-btn"
        data-width="full"
        title={isArabic ? 'تمام عرض' : 'Full width'}
      >
        <!-- Expand / full width icon -->
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="15 3 21 3 21 9" />
          <polyline points="9 21 3 21 3 15" />
          <line x1="21" y1="3" x2="14" y2="10" />
          <line x1="3" y1="21" x2="10" y2="14" />
        </svg>
        <span class="btn-label">XL</span>
      </button>
    </div>

    <!-- Go to Top Button -->
    <button
      id="go-to-top-btn"
      class="go-to-top-btn"
      title={isArabic ? 'برو به بالا' : 'Go to top'}
      aria-label={isArabic ? 'برو به بالا' : 'Go to top'}
    >
      <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
        <line x1="12" y1="19" x2="12" y2="5" />
        <polyline points="5 12 12 5 19 12" />
      </svg>
    </button>
  </div>
</header>

<style>
  /* =============================================
     FLOATING HEADER - uses high specificity 
     intentionally to avoid @layer issues
     ============================================= */
  .floating-header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    /* z-index BELOW site nav (usually z-40/50), but above content */
    z-index: 25;
    background: linear-gradient(135deg, rgb(26 95 122) 0%, rgb(41 128 185) 100%);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    padding: 0.5rem 1rem;
    transform: translateY(-100%);
    opacity: 0;
    pointer-events: none;
    transition: transform 0.3s ease-out, opacity 0.3s ease-out;
  }

  .floating-header.is-visible {
    transform: translateY(0);
    opacity: 1;
    pointer-events: auto;
  }

  .floating-header-content {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    max-width: 90vw;
    height: auto;
    margin: 0 auto;
    padding: 0 1rem;
  }

  .header-info {
    flex: 1;
    min-width: 0;
  }

  .header-title {
    font-size: 0.875rem;
    font-weight: 600;
    color: white;
    margin: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .header-author {
    font-size: 0.75rem;
    color: rgba(255, 255, 255, 0.8);
    margin: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .width-options {
    display: flex;
    gap: 0.375rem;
    flex-shrink: 0;
  }

  .width-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem;
    padding: 0.4rem 0.6rem;
    background: rgba(255, 255, 255, 0.12);
    border: 1px solid rgba(255, 255, 255, 0.25);
    border-radius: 0.375rem;
    color: rgba(255, 255, 255, 0.85);
    font-size: 0.7rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
    line-height: 1;
  }

  .width-btn:hover {
    background: rgba(255, 255, 255, 0.25);
    border-color: rgba(255, 255, 255, 0.5);
    color: white;
    transform: translateY(-1px);
  }

  .width-btn.active {
    background: rgba(255, 255, 255, 0.3);
    border-color: white;
    color: white;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.25);
  }

  .btn-label {
    font-weight: 700;
    letter-spacing: 0.02em;
  }

  .go-to-top-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 2.25rem;
    height: 2.25rem;
    padding: 0;
    background: rgba(255, 255, 255, 0.12);
    border: 1px solid rgba(255, 255, 255, 0.25);
    border-radius: 0.375rem;
    color: rgba(255, 255, 255, 0.85);
    cursor: pointer;
    transition: all 0.2s;
    flex-shrink: 0;
  }

  .go-to-top-btn:hover {
    background: rgba(255, 255, 255, 0.25);
    border-color: rgba(255, 255, 255, 0.5);
    color: white;
    transform: translateY(-2px);
  }

  /* ===== Responsive ===== */
  @media (max-width: 768px) {
    .floating-header {
      padding: 0.375rem 0.5rem;
    }

    .floating-header-content {
      gap: 0.5rem;
      padding: 0 0.5rem;
    }

    .header-info {
      display: none; /* Hide title on mobile to save space */
    }

    .width-btn {
      padding: 0.35rem 0.5rem;
      font-size: 0.625rem;
    }

    .width-btn svg {
      width: 14px;
      height: 14px;
    }

    .go-to-top-btn {
      width: 2rem;
      height: 2rem;
    }
  }

  @media (max-width: 1023px) {
    /* Optionally hide on very small screens — remove this block if you want it everywhere */
    /* #width-toggle-header { display: none !important; } */
  }
</style>

<script is:inline>
  (function () {
    'use strict';

    const WIDTH_MAP = {
      default: '56rem',   // 896px
      '1024': '1024px',
      '1280': '1280px',
      full: '90vw',
    };

    // ---- Selectors for the content container AND any ancestor wrappers ----
    // Add more selectors here if your BaseLayout wraps content in another div
    const CONTAINER_SELECTORS = [
      'article.container-article',
      '.container-article',
      'div.container-wide',
      '.container-wide',
    ];

    const ANCESTOR_SELECTORS = [
      'main',                // common wrapper
      '.main-content',       // possible wrapper
      '[class*="container"]', // any generic container ancestor (careful)
    ];

    function findContentContainer() {
      for (const sel of CONTAINER_SELECTORS) {
        const el = document.querySelector(sel);
        if (el) return el;
      }
      return null;
    }

    /**
     * Walk up from `container` and loosen any ancestor that has a restrictive
     * max-width (smaller than the desired width).  Stores originals so we can
     * restore when switching back to a smaller size.
     */
    function loosenAncestors(container, desiredMaxWidth) {
      let el = container.parentElement;
      while (el && el !== document.documentElement) {
        const computed = window.getComputedStyle(el);
        const currentMax = computed.maxWidth;

        // If ancestor has a constraining max-width, override it
        if (currentMax && currentMax !== 'none') {
          const currentPx = parseFloat(currentMax);
          const desiredPx =
            desiredMaxWidth === '90vw'
              ? window.innerWidth * 0.9
              : parseFloat(desiredMaxWidth);

          if (!isNaN(currentPx) && currentPx < desiredPx) {
            // Save original so we can restore later
            if (!el.dataset.origMaxWidth) {
              el.dataset.origMaxWidth = el.style.maxWidth || '';
            }
            el.style.setProperty('max-width', desiredMaxWidth, 'important');
          }
        }
        el = el.parentElement;
      }
    }

    function restoreAncestors(container) {
      let el = container.parentElement;
      while (el && el !== document.documentElement) {
        if (el.dataset.origMaxWidth !== undefined) {
          el.style.maxWidth = el.dataset.origMaxWidth;
          delete el.dataset.origMaxWidth;
        }
        el = el.parentElement;
      }
    }

    function initWidthToggle() {
      const header = document.getElementById('width-toggle-header');
      const headerContent = document.getElementById('floating-header-content');
      const widthBtns = document.querySelectorAll('.width-btn');
      const goToTopBtn = document.getElementById('go-to-top-btn');
      const container = findContentContainer();

      if (!header) return;

      if (!container) {
        console.warn('[WidthToggle] No content container found — toggle disabled.');
        header.style.display = 'none';
        return;
      }

      // ---- Apply saved width (or default) ----
      const saved = localStorage.getItem('content-width') || 'default';
      applyWidth(saved);
      setActiveBtn(saved);

      // ---- Scroll-based visibility ----
      let visible = false;
      const SHOW_AFTER = 300; // px

      function onScroll() {
        const y = window.scrollY || document.documentElement.scrollTop;
        if (y > SHOW_AFTER && !visible) {
          visible = true;
          header.classList.add('is-visible');
          header.setAttribute('aria-hidden', 'false');
        } else if (y <= SHOW_AFTER && visible) {
          visible = false;
          header.classList.remove('is-visible');
          header.setAttribute('aria-hidden', 'true');
        }
      }

      // Throttle via rAF
      let ticking = false;
      window.addEventListener('scroll', function () {
        if (!ticking) {
          window.requestAnimationFrame(function () {
            onScroll();
            ticking = false;
          });
          ticking = true;
        }
      }, { passive: true });

      // Initial check (in case page loads already scrolled)
      onScroll();

      // ---- Button clicks ----
      widthBtns.forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();
          var w = btn.getAttribute('data-width');
          applyWidth(w);
          setActiveBtn(w);
          localStorage.setItem('content-width', w);
        });
      });

      // ---- Go to top ----
      if (goToTopBtn) {
        goToTopBtn.addEventListener('click', function () {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
      }

      // ---- Core: apply width to content ----
      function applyWidth(key) {
        var value = WIDTH_MAP[key];
        if (!value) value = WIDTH_MAP['default'];

        // 1. Restore any previously loosened ancestors
        restoreAncestors(container);

        // 2. Set container width
        container.style.setProperty('max-width', value, 'important');
        container.style.setProperty('width', '100%', 'important');
        container.style.setProperty('margin-left', 'auto', 'important');
        container.style.setProperty('margin-right', 'auto', 'important');

        // 3. Transition hint
        container.style.setProperty('transition', 'max-width 0.35s ease-in-out');

        // 4. Loosen any parent that clips us
        loosenAncestors(container, value);

        // 5. Set data attribute on <html> for CSS fallback
        document.documentElement.setAttribute('data-content-width', key);

        // =========== ADD THIS BLOCK ===========
        // 6. Override .prose max-width so content actually fills the container
        var proseEls = container.querySelectorAll('.prose');
        proseEls.forEach(function (prose) {
          if (key === 'default') {
            prose.style.removeProperty('max-width');
          } else {
            prose.style.setProperty('max-width', 'none', 'important');
          }
        });
        // ======================================

        // 7. Match header content width
        if (headerContent) {
          headerContent.style.setProperty('max-width', value, 'important');
        }
      }

      function setActiveBtn(activeKey) {
        widthBtns.forEach(function (btn) {
          if (btn.getAttribute('data-width') === activeKey) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      }
    }

    // ---- Bootstrap ----
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initWidthToggle);
    } else {
      initWidthToggle();
    }

    // Astro view-transitions support
    document.addEventListener('astro:after-swap', initWidthToggle);
    document.addEventListener('astro:page-load', initWidthToggle);
  })();
</script>