---
interface Props {
  images: string[] | null;
}

const { images = [] } = Astro.props;
const validImages = images || [];
---

{validImages.length > 0 && (
  <div class="premium-slider relative w-full overflow-hidden rounded-2xl shadow-xl bg-surface-dim dark:bg-surface-dark-dim aspect-[16/10] sm:aspect-[4/3] md:aspect-video group">
    <!-- Slides -->
    <div class="slider-track flex transition-transform duration-500 ease-[cubic-bezier(0.25,1,0.5,1)] h-full w-full">
      {validImages.map((img, i) => (
        <div class="slide shrink-0 w-full h-full flex items-center justify-center p-4">
          <img 
            src={img} 
            alt={`Slide ${i + 1}`} 
            class="max-w-full max-h-full object-contain rounded-lg drop-shadow-[0_8px_24px_rgba(0,0,0,0.15)]" 
            loading={i === 0 ? 'eager' : 'lazy'} 
          />
        </div>
      ))}
    </div>

    <!-- Navigation Arrows -->
    {validImages.length > 1 && (
      <>
        <button class="slider-nav prev absolute left-4 top-1/2 -translate-y-1/2 w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-full bg-white/20 dark:bg-black/30 text-text dark:text-white backdrop-blur-md opacity-0 group-hover:opacity-100 transition-all duration-300 hover:bg-white/40 dark:hover:bg-black/50 hover:scale-110 shadow-lg z-10" aria-label="Previous">
          <svg class="w-5 h-5 sm:w-6 sm:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M15 19l-7-7 7-7"></path></svg>
        </button>
        <button class="slider-nav next absolute right-4 top-1/2 -translate-y-1/2 w-10 h-10 sm:w-12 sm:h-12 flex items-center justify-center rounded-full bg-white/20 dark:bg-black/30 text-text dark:text-white backdrop-blur-md opacity-0 group-hover:opacity-100 transition-all duration-300 hover:bg-white/40 dark:hover:bg-black/50 hover:scale-110 shadow-lg z-10" aria-label="Next">
          <svg class="w-5 h-5 sm:w-6 sm:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M9 5l7 7-7 7"></path></svg>
        </button>

        <!-- Dots -->
        <div class="slider-dots absolute bottom-4 left-1/2 -translate-x-1/2 flex gap-2.5 p-2 rounded-full bg-white/20 dark:bg-black/30 backdrop-blur-md shadow-sm z-10">
          {validImages.map((_, i) => (
            <button class={`slider-dot h-2.5 rounded-full transition-all duration-300 ease-out shadow-inner ${i === 0 ? 'bg-primary dark:bg-primary-light w-8' : 'bg-text-muted/40 hover:bg-text-muted/70 dark:bg-white/50 dark:hover:bg-white/80 w-2.5'}`} data-index={i} aria-label={`Go to slide ${i + 1}`}></button>
          ))}
        </div>
      </>
    )}
  </div>
)}

<script>
  class PremiumSlider {
    container: HTMLElement;
    track: HTMLElement | null;
    slides: NodeListOf<Element>;
    dots: NodeListOf<Element>;
    prevBtn: HTMLElement | null;
    nextBtn: HTMLElement | null;
    currentIndex: number;
    totalSlides: number;
    isRtl: boolean;

    constructor(container: HTMLElement) {
      this.container = container;
      this.track = container.querySelector('.slider-track');
      this.slides = container.querySelectorAll('.slide');
      this.dots = container.querySelectorAll('.slider-dot');
      this.prevBtn = container.querySelector('.slider-nav.prev');
      this.nextBtn = container.querySelector('.slider-nav.next');
      this.currentIndex = 0;
      this.totalSlides = this.slides.length;
      
      // Determine RTL
      const dir = document.documentElement.getAttribute('dir') || 'ltr';
      this.isRtl = dir === 'rtl';

      if (this.totalSlides <= 1) return;

      this.initEvents();
    }

    initEvents() {
      // Swipe support
      let touchStartX = 0;
      let touchEndX = 0;
      this.container.addEventListener('touchstart', (e: any) => { touchStartX = e.changedTouches[0].screenX; }, {passive: true});
      this.container.addEventListener('touchend', (e: any) => { 
        touchEndX = e.changedTouches[0].screenX; 
        this.handleSwipe(touchStartX, touchEndX);
      }, {passive: true});

      // in RTL, left arrow is "next", right arrow is "prev" (or visually previous/next context overrides it)
      // Visual next is right. Visual prev is left.
      // If we are looking right and in RTL flex, it moves backwards in array.
      // Let's just keep next/prev logical buttons independent of visual if we swap the icons or positions! Wait, I positioned them visually: next is right, prev is left.
      
      this.prevBtn?.addEventListener('click', () => {
         this.goToSlide(this.isRtl ? this.currentIndex + 1 : this.currentIndex - 1);
      });
      this.nextBtn?.addEventListener('click', () => {
         this.goToSlide(this.isRtl ? this.currentIndex - 1 : this.currentIndex + 1);
      });
      
      this.dots.forEach((dot: Element, index: number) => {
        dot.addEventListener('click', () => this.goToSlide(index));
      });
    }

    handleSwipe(start: number, end: number) {
      const threshold = 50;
      // swipe left (start > end) -> moving content left -> showing content from right (logical next in LTR, logical prev in RTL)
      if (start - end > threshold) {
         this.goToSlide(this.isRtl ? this.currentIndex - 1 : this.currentIndex + 1);
      } 
      // swipe right (end > start) -> moving content right -> showing content from left
      else if (end - start > threshold) {
         this.goToSlide(this.isRtl ? this.currentIndex + 1 : this.currentIndex - 1);
      }
    }

    goToSlide(index: number) {
      if (index < 0) index = this.totalSlides - 1;
      if (index >= this.totalSlides) index = 0;
      
      this.currentIndex = index;
      
      // In RTL, items are laid out right-to-left. 
      // To show item #1, we use transform translateX(100%), but in modern browsers css transform behaves relative to flow? 
      // No, translateX(100%) always goes right visually.
      // In RTL flex-container, index 0 is at the right edge. Viewport is at 0.
      // Index 1 is to the left of 0 (from -100% to -0%).
      // To show index 1, we must move the track to the right by 100%. translateX(100%).
      const directionMult = this.isRtl ? 1 : -1;
      const offset = directionMult * 100 * this.currentIndex;
      
      if(this.track) {
         this.track.style.transform = `translateX(${offset}%)`;
      }

      // Update dots classes
      this.dots.forEach((dot: Element, i: number) => {
        if (i === this.currentIndex) {
           dot.classList.add('bg-primary', 'dark:bg-primary-light', 'w-8');
           dot.classList.remove('bg-text-muted/40', 'dark:bg-white/50', 'w-2.5');
        } else {
           dot.classList.add('bg-text-muted/40', 'dark:bg-white/50', 'w-2.5');
           dot.classList.remove('bg-primary', 'dark:bg-primary-light', 'w-8');
        }
      });
    }
  }

  const initSliders = () => {
    const sliders = document.querySelectorAll('.premium-slider');
    sliders.forEach(slider => {
      // Avoid double initialization
      if(!slider.hasAttribute('data-initialized')) {
        new PremiumSlider(slider as HTMLElement);
        slider.setAttribute('data-initialized', 'true');
      }
    });
  };
  
  // Clean initialization to work well with Astro View Transitions
  document.addEventListener('DOMContentLoaded', initSliders);
  document.addEventListener('astro:page-load', initSliders);
</script>
