---
import BaseLayout from '../../layouts/BaseLayout.astro';
import BookLayout from '../../layouts/BookLayout.astro';
import { t } from '../../i18n';
import { getCollection, render } from 'astro:content';

const lang = 'fa';
const stripPrefix = (id: string) => id.replace(/^fa\//, '');

export async function getStaticPaths() {
  const strip = (id: string) => id.replace(/^fa\//, '');
  const allBooks = await getCollection('books', ({ data }) => data.lang === 'fa');

  const bookMap = new Map();

  // 1. Identify Books (Overviews)
  for (const book of allBooks) {
    const isExplicitBook = !book.data.bookSlug && !book.id.includes('/'); // Legacy flat book
    const isIndexBook = book.id.endsWith('/index.md') || book.id.endsWith('/index.mdx'); // New folder book

    if (isExplicitBook || isIndexBook) {
      bookMap.set(book.id, { entry: book, chapters: [] });
    }
  }

  // 2. Identify Chapters and Link to Books
  for (const file of allBooks) {
    if (bookMap.has(file.id)) continue; // Skip books themselves

    let bookId = file.data.bookSlug;

    // implicit association: check if file is in a folder that is a book
    if (!bookId && file.id.includes('/')) {
        const parts = file.id.split('/');
        parts.pop(); // remove filename
        const folderPath = parts.join('/');
        
        // Check for index.md or index.mdx in the same folder
        const potentialIndexMd = `${folderPath}/index.md`;
        const potentialIndexMdx = `${folderPath}/index.mdx`;
        
        if (bookMap.has(potentialIndexMd)) {
            bookId = potentialIndexMd;
        } else if (bookMap.has(potentialIndexMdx)) {
            bookId = potentialIndexMdx;
        }
    }

    if (bookId && bookMap.has(bookId)) {
        bookMap.get(bookId).chapters.push(file);
    }
  }

  const paths = [];

  // 3. Generate paths
  for (const [bookId, { entry, chapters }] of bookMap.entries()) {
    // Sort chapters
    chapters.sort((a: any, b: any) => (a.data.chapterNumber ?? 0) - (b.data.chapterNumber ?? 0));

    // Prepare book slug
    let rawBookSlug = strip(bookId);
    // For folder books: fa/sample-book/index.md -> sample-book
    // For flat books: fa/ethical.md -> ethical
    let bookSlugClean = rawBookSlug.replace(/\/index\.mdx?$/, '').replace(/\.mdx?$/, '');

    // Book Overview Path
    paths.push({
      params: { slug: bookSlugClean },
      props: { entry: entry, chapters: chapters, isChapter: false, bookSlugOverride: bookSlugClean },
    });

    // Chapter Paths
    for (const chapter of chapters) {
        const idx = chapters.findIndex((c: any) => c.id === chapter.id);
        
        // Determine chapter slug
        // Flat: fa/ch01.md -> ch01.md -> ch01. joined with book: ethical/ch01
        // Folder: fa/sample-book/ch01.md -> sample-book/ch01.md -> sample-book/ch01
        
        let finalSlug = '';
        if (chapter.id.includes('/index.md')) continue; // Should not happen but safety

        if (chapter.id.includes('/')) {
             // Folder structure: fa/sample-book/ch01.md
             // strip -> sample-book/ch01.md
             // remove ext -> sample-book/ch01
             finalSlug = strip(chapter.id).replace(/\.mdx?$/, '');
        } else {
             // Flat structure: fa/ch01.md
             // strip -> ch01.md
             // remove ext -> ch01
             // Prepend book slug
             finalSlug = `${bookSlugClean}/${strip(chapter.id).replace(/\.mdx?$/, '')}`;
        }

        paths.push({
            params: { slug: finalSlug },
            props: {
                entry: chapter,
                chapters: chapters,
                isChapter: true,
                prevChapter: idx > 0 ? chapters[idx - 1] : undefined,
                nextChapter: idx < chapters.length - 1 ? chapters[idx + 1] : undefined,
                bookSlugOverride: bookSlugClean
            },
        });
    }
  }

  return paths;
}

const { entry, chapters, isChapter, prevChapter, nextChapter, bookSlugOverride } = Astro.props;
const { Content, headings } = await render(entry);

// Determine book slug for UI links
// Priority: passed override -> entry data -> entry id
const rawBookSlug = entry.data.bookSlug ?? bookSlugOverride ?? entry.id;
let bookSlugClean = stripPrefix(rawBookSlug);
bookSlugClean = bookSlugClean.replace(/\/index\.mdx?$/, '').replace(/\.mdx?$/, '');

const chapterList = chapters.map((c: any) => {
  let slug = stripPrefix(c.id).replace(/\.mdx?$/, '');
  
  // If the chapter slug starts with the book slug (folder structure), remove it for relative linking if needed
  // BUT: The UI links are constructed as `/books/${bookSlugClean}/${ch.slug}`
  // If ch.slug is `sample-book/ch01` and bookSlugClean is `sample-book`, result: `/books/sample-book/sample-book/ch01` (WRONG)
  // We want ch.slug to be just partial if we prepend bookSlugClean.
  
  // If flat: ch.slug is `ch01`. Link: `/books/ethical/ch01`. Correct.
  // If folder: ch.slug is `sample-book/ch01`. Link: `/books/sample-book/sample-book/ch01`. Wrong.
  
  // Fix: If slug starts with bookSlugClean, strip it.
  if (slug.startsWith(bookSlugClean + '/')) {
      slug = slug.substring(bookSlugClean.length + 1);
  }
  
  return {
    slug: slug,
    title: c.data.title,
    chapterNumber: c.data.chapterNumber ?? 0,
  };
});
---

{isChapter ? (
  <BookLayout
    title={entry.data.title}
    description={entry.data.description}
    lang={lang}
    bookSlug={bookSlugClean}
    chapterNumber={entry.data.chapterNumber}
    chapters={chapterList}
    headings={headings}
    prevChapter={prevChapter ? { slug: stripPrefix(prevChapter.id), title: prevChapter.data.title, chapterNumber: prevChapter.data.chapterNumber ?? 0 } : undefined}
    nextChapter={nextChapter ? { slug: stripPrefix(nextChapter.id), title: nextChapter.data.title, chapterNumber: nextChapter.data.chapterNumber ?? 0 } : undefined}
    draft={entry.data.draft}
  >
    <Content />
  </BookLayout>
) : (
  <BaseLayout title={entry.data.title} description={entry.data.description}>
    <div class="container-narrow py-16">
      {entry.data.coverImage && (
        <img src={entry.data.coverImage} alt={entry.data.title} class="w-full max-w-sm mx-auto rounded-xl mb-8" loading="lazy" />
      )}
      <h1 class="text-3xl md:text-4xl font-bold mb-4">{entry.data.title}</h1>
      <p class="text-lg text-text-muted dark:text-text-dark-muted mb-8">{entry.data.description}</p>

      {chapterList.length > 0 && (
        <div class="mb-8">
          <h2 class="text-xl font-bold mb-4">{t('books.toc', lang)}</h2>
          <ol class="space-y-2">
            {chapterList.map((ch: any) => (
              <li>
                <a
                  href={`/books/${bookSlugClean}/${ch.slug}`}
                  class="flex items-center gap-3 p-3 rounded-lg border border-border dark:border-border-dark hover:border-primary dark:hover:border-primary-light transition-colors no-underline"
                >
                  <span class="text-sm text-text-muted dark:text-text-dark-muted w-8 text-center shrink-0">
                    {ch.chapterNumber}
                  </span>
                  <span class="text-text-base dark:text-text-dark font-medium">{ch.title}</span>
                </a>
              </li>
            ))}
          </ol>
        </div>
      )}

      {entry.data.pdfUrl && (
        <a
          href={entry.data.pdfUrl}
          class="inline-flex items-center gap-2 px-5 py-2.5 rounded-lg bg-secondary text-white font-medium hover:bg-secondary-light transition-colors no-underline"
          download
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/></svg>
          {t('books.download_pdf', lang)}
        </a>
      )}

      <div class="prose mt-8">
        <Content />
      </div>
    </div>
  </BaseLayout>
)}
